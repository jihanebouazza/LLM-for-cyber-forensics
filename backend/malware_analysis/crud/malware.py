from uuid import uuid4
from sqlalchemy.orm import Session

from ..models import MalwareSample, MalwareAnalysis, MalwareIOC, MalwareCapability, MalwareConfig, MalwareRecommendAction, MalwareDetectionHint, MalwareCluster, MalwareClusterMember, Campaign
from ..schemas.requests import MalwareAnalyzeRequest


def analyze_sample(db: Session, payload: MalwareAnalyzeRequest):
    # --- 0) Dedup sample by hash ---
    sample = None
    if payload.hash:
        sample = get_sample_by_hash(db, payload.hash)

    if not sample:
        sample = MalwareSample(
            id=uuid4(),
            filename=payload.filename,
            hash=payload.hash,
            file_type=payload.static.file_type if payload.static else None,
            malware_family=payload.static.detected_family if payload.static else None,
        )
        db.add(sample)
        db.flush()  # ensures sample.id exists
    else:
        # keep sample metadata fresh if new request provides it
        if payload.static:
            if payload.static.file_type and not sample.file_type:
                sample.file_type = payload.static.file_type
            if payload.static.detected_family and not sample.malware_family:
                sample.malware_family = payload.static.detected_family

    family = sample.malware_family
    if family:
        cluster_name = f"family:{family}"
        created_or_found_cluster = get_cluster_by_name(db, cluster_name)
        if not created_or_found_cluster:
            created_or_found_cluster = create_cluster(
                db,
                cluster_name=cluster_name,
                description=f"Auto cluster for malware family {family}",
            )
        add_sample_to_cluster(db, created_or_found_cluster.id, sample.id)
    # --- 1) Always compute behaviors + risk for THIS request ---
    risk_score = 1
    risk_level = "low"
    behaviors_list: list[str] = []

    if payload.dynamic and payload.dynamic.behaviors:
        behaviors_list = [
            b.action for b in payload.dynamic.behaviors if b.action]
        if len(behaviors_list) > 5:
            risk_score = 7
            risk_level = "high"
        elif len(behaviors_list) > 0:
            risk_score = 4
            risk_level = "medium"

    behavior_summary = "Basic rule-based analysis from sandbox report."

    # --- 2) Always create a NEW analysis entry (history) ---
    analysis = MalwareAnalysis(
        id=uuid4(),
        sample_id=sample.id,
        risk_score=risk_score,
        risk_level=risk_level,
        behavior_summary=behavior_summary,
        behaviors=behaviors_list,
    )
    db.add(analysis)

    # --- 3) Derived data: create only once per sample (current design) ---
    created_iocs = []
    created_caps = []
    created_cfg = None
    created_recs = []
    created_hints = []

    if not has_existing_derived_data(db, sample.id):
        iocs_data = extract_iocs_from_request(payload)
        created_iocs = create_iocs(db, sample.id, iocs_data)

        capability_names = extract_capabilities_from_behaviors(behaviors_list)
        created_caps = create_capabilities(db, sample.id, capability_names)

        cfg_data = extract_config_from_iocs_and_behaviors(
            iocs_data, behaviors_list)
        if cfg_data:
            created_cfg = create_config(db, sample.id, cfg_data)

        actions = generate_recommendations(
            risk_level=risk_level,
            sample_hash=payload.hash,
            iocs_data=iocs_data,
            capabilities=capability_names,
            config=cfg_data,
        )
        created_recs = create_recommendations(db, sample.id, actions)

        hints_data = generate_detection_hints(
            sample_hash=payload.hash,
            iocs_data=iocs_data,
            capabilities=capability_names,
            config=cfg_data,
        )
        created_hints = create_detection_hints(db, sample.id, hints_data)

    # --- 4) Commit once ---
    db.commit()

    # --- 5) Refresh objects ---
    db.refresh(sample)
    db.refresh(analysis)

    for obj in created_iocs:
        db.refresh(obj)
    for obj in created_caps:
        db.refresh(obj)
    if created_cfg:
        db.refresh(created_cfg)
    for obj in created_recs:
        db.refresh(obj)
    for obj in created_hints:
        db.refresh(obj)

    # --- 6) Return: if derived already exists, return existing derived from DB ---
    if has_existing_derived_data(db, sample.id) and not created_iocs:
        iocs = db.query(MalwareIOC).filter_by(sample_id=sample.id).all()
        caps = db.query(MalwareCapability).filter_by(sample_id=sample.id).all()
        cfg = db.query(MalwareConfig).filter_by(sample_id=sample.id).first()
        recs = db.query(MalwareRecommendAction).filter_by(
            sample_id=sample.id).all()
        hints = db.query(MalwareDetectionHint).filter_by(
            sample_id=sample.id).all()
        analyses = db.query(MalwareAnalysis).filter_by(
            sample_id=sample.id).all()
        return sample, analyses, iocs, caps, cfg, recs, hints

    # If we just created derived data now:
    analyses = db.query(MalwareAnalysis).filter_by(sample_id=sample.id).all()
    return sample, analyses, created_iocs, created_caps, created_cfg, created_recs, created_hints


def get_sample_by_hash(db: Session, sample_hash: str):
    return db.query(MalwareSample).filter(MalwareSample.hash == sample_hash).first()


def has_existing_derived_data(db: Session, sample_id) -> bool:
    return db.query(MalwareIOC).filter(MalwareIOC.sample_id == sample_id).first() is not None


def create_iocs(db: Session, sample_id, iocs: list[dict]) -> list[MalwareIOC]:
    created = []
    for ioc in iocs:
        obj = MalwareIOC(
            id=uuid4(),
            sample_id=sample_id,
            ioc_type=ioc["ioc_type"],
            value=ioc["value"],
            description=ioc.get("description"),
            source=ioc.get("source"),
        )
        db.add(obj)
        created.append(obj)
    return created


def get_iocs_for_sample(db: Session, sample_id):
    return (
        db.query(MalwareIOC)
        .filter(MalwareIOC.sample_id == sample_id)
        .all()
    )


def extract_iocs_from_request(payload) -> list[dict]:
    iocs: list[dict] = []

    # 1) From static (hardcoded indicators in the binary / report)
    if payload.static:
        if getattr(payload.static, "domains", None):
            for d in payload.static.domains:
                iocs.append({
                    "ioc_type": "domain",
                    "value": d,
                    "description": "Domain found in static report",
                    "source": "static",
                })

        if getattr(payload.static, "urls", None):
            for u in payload.static.urls:
                iocs.append({
                    "ioc_type": "url",
                    "value": u,
                    "description": "URL found in static report",
                    "source": "static",
                })

        if getattr(payload.static, "mutexes", None):
            for m in payload.static.mutexes:
                iocs.append({
                    "ioc_type": "mutex",
                    "value": m,
                    "description": "Mutex found in static report",
                    "source": "static",
                })

    # 2) From dynamic behaviors (file-centric behaviors)
    if payload.dynamic and getattr(payload.dynamic, "behaviors", None):
        for b in payload.dynamic.behaviors:
            action = getattr(b, "action", None)
            target = getattr(b, "target", None)

            if not action or not target:
                continue

            if action in {"create_file", "modify_file", "delete_file"}:
                iocs.append({
                    "ioc_type": "file_path",
                    "value": target,
                    "description": f"Observed file operation: {action}",
                    "source": "dynamic",
                })

            if action in {"modify_registry", "create_registry", "delete_registry"}:
                iocs.append({
                    "ioc_type": "registry_key",
                    "value": target,
                    "description": f"Observed registry operation: {action}",
                    "source": "dynamic",
                })

            if action == "create_mutex":
                iocs.append({
                    "ioc_type": "mutex",
                    "value": target,
                    "description": "Observed mutex creation",
                    "source": "dynamic",
                })

    # Deduplicate by (ioc_type, value)
    unique = {}
    for i in iocs:
        key = (i["ioc_type"], i["value"])
        unique[key] = i
    return list(unique.values())


def extract_capabilities_from_behaviors(behaviors: list[str]) -> list[str]:
    caps: set[str] = set()

    # Basic mapping (edit to match behavior vocabulary)
    for b in behaviors:
        b = (b or "").lower()

        if b in {"modify_registry", "create_registry", "delete_registry"}:
            caps.add("persistence_possible")

        if b in {"create_file", "modify_file", "delete_file"}:
            caps.add("file_system_modification")

        if b in {"encrypt_files", "encrypt_file"}:
            caps.add("encryption")

        if b in {"create_process", "spawn_process", "execute_process"}:
            caps.add("process_execution")

        if b in {"inject_process", "process_injection"}:
            caps.add("process_injection")

        if b in {"keylogging", "keylogger"}:
            caps.add("keylogging")

        if b in {"credential_theft", "steal_credentials"}:
            caps.add("credential_theft")

    return sorted(caps)


def create_capabilities(db: Session, sample_id, capabilities: list[str]) -> list[MalwareCapability]:
    created: list[MalwareCapability] = []
    for cap in capabilities:
        obj = MalwareCapability(
            id=uuid4(),
            sample_id=sample_id,
            capability=cap,
        )
        db.add(obj)
        created.append(obj)
    return created


def get_capabilities_for_sample(db: Session, sample_id):
    return (
        db.query(MalwareCapability)
        .filter(MalwareCapability.sample_id == sample_id)
        .all()
    )


def extract_config_from_iocs_and_behaviors(iocs: list[dict], behaviors: list[str]) -> dict | None:
    # infer ransomware config if a ransom note is created
    ransom_note_name = None
    target_folders: list[str] = []
    encryption_extension = None

    # From file_path IOCs
    for i in iocs:
        if i["ioc_type"] == "file_path":
            path = i["value"]

            # If you created README.txt as ransom note
            if path.lower().endswith("\\readme.txt") or path.lower().endswith("\\readme.html"):
                ransom_note_name = path.split("\\")[-1]

            # Collect folder targets
            if "\\" in path:
                folder = "\\".join(path.split("\\")[:-1])
                target_folders.append(folder)

    # From behavior names
    if any(b.lower() in {"encrypt_files", "encrypt_file"} for b in behaviors):
        # Example placeholder extension; later extract from report if available
        encryption_extension = ".encrypted"

    # If nothing ransomware-like found, return None (no config row created)
    if not ransom_note_name and not encryption_extension and not target_folders:
        return None

    # Deduplicate folders
    target_folders = sorted(list(set(target_folders)))

    return {
        "ransom_note_name": ransom_note_name,
        "encryption_extension": encryption_extension,
        "target_folders": target_folders or None,
    }


def create_config(db: Session, sample_id, cfg: dict) -> MalwareConfig:
    obj = MalwareConfig(
        id=uuid4(),
        sample_id=sample_id,
        ransom_note_name=cfg.get("ransom_note_name"),
        encryption_extension=cfg.get("encryption_extension"),
        target_folders=cfg.get("target_folders"),
    )
    db.add(obj)
    return obj


def get_config_for_sample(db: Session, sample_id):
    return db.query(MalwareConfig).filter(MalwareConfig.sample_id == sample_id).first()


def generate_recommendations(
    risk_level: str,
    sample_hash: str | None,
    iocs_data: list[dict],
    capabilities: list[str],
    config: dict | None,
) -> list[str]:
    recs: list[str] = []

    # Always useful
    if sample_hash:
        recs.append(
            f"Block this hash in EDR/AV across endpoints: {sample_hash}")
        recs.append(
            f"Search endpoints for this hash in EDR telemetry: {sample_hash}")

    # Risk-driven
    if risk_level in {"high", "critical"}:
        recs.append(
            "Prioritize incident response: isolate affected hosts and collect volatile evidence.")
    elif risk_level == "medium":
        recs.append(
            "Increase monitoring on potentially impacted hosts and review recent execution history.")
    else:
        recs.append("Keep under observation; triage if new activity appears.")

    # Capability-driven
    if "persistence_possible" in capabilities:
        recs.append(
            "Hunt for persistence artifacts, especially Run/RunOnce registry keys and startup folders.")
    if "encryption" in capabilities:
        recs.append(
            "Immediately verify backups and identify encrypted file patterns across endpoints.")
    if "credential_theft" in capabilities:
        recs.append(
            "Force password reset for impacted users and check for suspicious authentications.")

    # IOC-driven (malware-only IOCs)
    reg_keys = [i["value"]
                for i in iocs_data if i["ioc_type"] == "registry_key"]
    if reg_keys:
        recs.append(
            f"Search endpoints for these registry keys: {', '.join(reg_keys[:5])}")

    file_paths = [i["value"]
                  for i in iocs_data if i["ioc_type"] == "file_path"]
    if file_paths:
        recs.append(
            f"Search endpoints for these file artifacts/paths: {', '.join(file_paths[:5])}")

    # Config-driven (ransomware-like)
    if config:
        if config.get("ransom_note_name"):
            recs.append(
                f"Hunt for ransom note file name: {config['ransom_note_name']}")
        if config.get("encryption_extension"):
            recs.append(
                f"Hunt for encrypted file extension: {config['encryption_extension']}")

    # Deduplicate while preserving order
    seen = set()
    out = []
    for r in recs:
        if r not in seen:
            out.append(r)
            seen.add(r)
    return out


def create_recommendations(db: Session, sample_id, actions: list[str]):
    created = []
    for text in actions:
        obj = MalwareRecommendAction(
            id=uuid4(),
            sample_id=sample_id,
            action_text=text,
        )
        db.add(obj)
        created.append(obj)
    return created


def get_recommendations_for_sample(db: Session, sample_id):
    return (
        db.query(MalwareRecommendAction)
        .filter(MalwareRecommendAction.sample_id == sample_id)
        .all()
    )


def generate_detection_hints(
    sample_hash: str | None,
    iocs_data: list[dict],
    capabilities: list[str],
    config: dict | None,
) -> list[dict]:
    hints: list[dict] = []

    # Hash-based
    if sample_hash:
        hints.append({
            "hint_type": "edr_hash",
            "hint_text": f"Hunt for process/file executions matching hash: {sample_hash}",
        })

    # IOC-based (malware-only)
    for i in iocs_data:
        if i["ioc_type"] == "registry_key":
            hints.append({
                "hint_type": "registry",
                "hint_text": f"Detect modifications to registry key: {i['value']}",
            })
        if i["ioc_type"] == "file_path":
            hints.append({
                "hint_type": "file",
                "hint_text": f"Detect creation/modification of file path: {i['value']}",
            })

    # Capability-based
    if "persistence_possible" in capabilities:
        hints.append({
            "hint_type": "persistence",
            "hint_text": "Monitor persistence locations (Run/RunOnce keys, Startup folders) for suspicious new entries.",
        })
    if "encryption" in capabilities:
        hints.append({
            "hint_type": "ransomware",
            "hint_text": "Detect bursts of file renames/writes consistent with encryption activity.",
        })

    # Config-based (ransomware-like)
    if config:
        if config.get("ransom_note_name"):
            hints.append({
                "hint_type": "ransom_note",
                "hint_text": f"Alert on creation of ransom note file name: {config['ransom_note_name']}",
            })
        if config.get("encryption_extension"):
            hints.append({
                "hint_type": "extension",
                "hint_text": f"Hunt for files created/renamed with extension: {config['encryption_extension']}",
            })

    # Deduplicate by (type, text)
    seen = set()
    out = []
    for h in hints:
        key = (h["hint_type"], h["hint_text"])
        if key not in seen:
            out.append(h)
            seen.add(key)
    return out


def create_detection_hints(db: Session, sample_id, hints: list[dict]):
    created = []
    for h in hints:
        obj = MalwareDetectionHint(
            id=uuid4(),
            sample_id=sample_id,
            hint_type=h["hint_type"],
            hint_text=h["hint_text"],
        )
        db.add(obj)
        created.append(obj)
    return created


def get_detection_hints_for_sample(db: Session, sample_id):
    return (
        db.query(MalwareDetectionHint)
        .filter(MalwareDetectionHint.sample_id == sample_id)
        .all()
    )


def get_cluster_by_name(db: Session, name: str):
    return db.query(MalwareCluster).filter(MalwareCluster.cluster_name == name).first()


def create_cluster(db: Session, cluster_name: str, description: str | None = None) -> MalwareCluster:
    obj = MalwareCluster(
        id=uuid4(),
        cluster_name=cluster_name,
        description=description,
    )
    db.add(obj)
    return obj


def add_sample_to_cluster(db: Session, cluster_id, sample_id) -> MalwareClusterMember:
    # avoid duplicates
    existing = (
        db.query(MalwareClusterMember)
        .filter(
            MalwareClusterMember.cluster_id == cluster_id,
            MalwareClusterMember.sample_id == sample_id
        )
        .first()
    )
    if existing:
        return existing

    obj = MalwareClusterMember(
        cluster_id=cluster_id,
        sample_id=sample_id,
    )
    db.add(obj)
    return obj


def get_clusters_for_sample(db: Session, sample_id):
    return (
        db.query(MalwareCluster)
        .join(MalwareClusterMember, MalwareClusterMember.cluster_id == MalwareCluster.id)
        .filter(MalwareClusterMember.sample_id == sample_id)
        .all()
    )


def get_cluster_members(db: Session, cluster_id):
    rows = (
        db.query(MalwareClusterMember)
        .filter(MalwareClusterMember.cluster_id == cluster_id)
        .all()
    )
    return [r.sample_id for r in rows]


def list_clusters(db: Session):
    return db.query(MalwareCluster).all()


def create_campaign(db: Session, name: str, description: str | None = None) -> Campaign:
    obj = Campaign(id=uuid4(), name=name, description=description)
    db.add(obj)
    return obj


def list_campaigns(db: Session):
    return db.query(Campaign).all()


def get_campaign(db: Session, campaign_id):
    return db.query(Campaign).filter(Campaign.id == campaign_id).first()


def get_campaign_by_name(db: Session, name: str):
    return db.query(Campaign).filter(Campaign.name == name).first()


def set_sample_campaign(db: Session, sample_id, campaign_id):
    sample = db.query(MalwareSample).filter(
        MalwareSample.id == sample_id).first()
    if not sample:
        return None
    sample.campaign_id = campaign_id
    return sample


def list_samples_by_campaign(db: Session, campaign_id):
    return db.query(MalwareSample).filter(MalwareSample.campaign_id == campaign_id).all()
