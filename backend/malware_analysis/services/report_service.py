from uuid import uuid4
from fastapi import UploadFile, HTTPException
from sqlalchemy.orm import Session
from .ollama_client import ollama_extract_from_text, extract_iocs_chunked, ollama_extract_behavior_block, ollama_extract_artifacts_block
import requests


from ..models import (
    MalwareSample,
    MalwareAnalysis,
    MalwareIOC,
    MalwareCapability,
    MalwareConfig,
    MalwareRecommendAction,
    MalwareDetectionHint,
)
from .pdf_text import extract_text_from_pdf_bytes
from ..schemas.report_responses import AnalyzeFromReportResponse
from ..utils.logging_utils import logger, Timer
from ..utils.non_ioc_validation import trim_for_non_iocs
from ..utils.report_topinfo import parse_anyrun_topinfo, map_sample_fields_from_topinfo


# def get_sample_by_hash(db: Session, sample_hash: str):
#     return db.query(MalwareSample).filter(MalwareSample.hash == sample_hash).first()


# def get_or_create_sample(db: Session, *, sample_hash: str | None, filename: str | None) -> MalwareSample:
#     if sample_hash:
#         sample = get_sample_by_hash(db, sample_hash)
#         if sample:
#             if filename and not sample.filename:
#                 sample.filename = filename
#             return sample

#     sample = MalwareSample(
#         id=uuid4(),
#         filename=filename,
#         hash=sample_hash,
#     )
#     db.add(sample)
#     db.flush()
#     return sample


def get_sample_by_hash(db: Session, sample_hash: str) -> MalwareSample | None:
    if not sample_hash:
        return None
    return db.query(MalwareSample).filter(MalwareSample.hash == sample_hash).first()


def get_or_create_sample(
    db: Session,
    sample_hash: str | None,
    filename: str | None,
    # created_at: datetime | None = None,
) -> MalwareSample:
    """
    - If sample_hash exists => try fetch by hash first
    - else create a new sample
    """
    sample = None
    if sample_hash:
        sample = get_sample_by_hash(db, sample_hash)

    if sample:
        # if filename missing in DB but provided now, fill it
        if filename and not sample.filename:
            sample.filename = filename
        return sample

    # Create new
    sample = MalwareSample(
        id=uuid4(),
        filename=filename,
        hash=sample_hash,
        # created_at=created_at,  # if your model auto-defaults, it's ok if None
    )
    db.add(sample)
    db.flush()
    return sample


def apply_sample_patch(sample: MalwareSample, patch: dict) -> None:
    """
    Only updates Malware_samples fields.
    Does NOT overwrite existing values with None/"".
    """
    if not sample or not isinstance(patch, dict):
        return

    def set_if_present(attr: str):
        val = patch.get(attr)
        if val is None:
            return
        if isinstance(val, str) and not val.strip():
            return
        # Only fill missing to be safe (you can change to always overwrite if you want)
        current = getattr(sample, attr, None)
        if current is None or (isinstance(current, str) and not current.strip()):
            setattr(sample, attr, val)

    # fields requested
    set_if_present("filename")
    set_if_present("hash")
    set_if_present("file_type")
    set_if_present("role_in_attack")
    set_if_present("category")
    set_if_present("malware_family")
    # set_if_present("campaign_id")
    set_if_present("variant_label")
    # set_if_present("created_at")


async def analyze_from_pdf_report(
    db: Session,
    upload: UploadFile,
    filename_override: str | None,
    sample_hash: str | None,
) -> AnalyzeFromReportResponse:

    t = Timer("Read PDF upload")
    raw = await upload.read()
    t.stop(extra=f"bytes={len(raw)}")

    if not raw:
        raise HTTPException(status_code=400, detail="Uploaded PDF is empty.")

    filename = filename_override or upload.filename

    t = Timer("Extract text from PDF")
    report_text = extract_text_from_pdf_bytes(raw).strip()
    t.stop(extra=f"chars={len(report_text)}")

    if len(report_text) < 300:
        raise HTTPException(
            status_code=422, detail="Not enough text extracted.")

    top = parse_anyrun_topinfo(report_text)
    patch = map_sample_fields_from_topinfo(top)

    # Apply explicit overrides (user input wins)
    if filename_override or upload.filename:
        patch["filename"] = filename_override or upload.filename

    # If user passed sample_hash explicitly, it wins
    if sample_hash:
        patch["hash"] = sample_hash

    # Get or create sample using best available hash
    t = Timer("Get or create sample")
    best_hash = patch.get("hash") or sample_hash
    sample = get_or_create_sample(
        db,
        sample_hash=best_hash,
        filename=patch.get("filename"),
        # created_at=patch.get("created_at"),
    )

    # Populate sample fields (only fill missing)

    apply_sample_patch(sample, patch)

    t.stop(extra=f"sample_id={sample.id}")

    t = Timer("LLM – extract IOCs (chunked)")
    iocs = extract_iocs_chunked(report_text)
    t.stop(extra=f"total_iocs={len(iocs)}")

    t = Timer("LLM – extract non-IOCs (split)")
    trimmed = trim_for_non_iocs(report_text)

    behav = {}
    art = {}

    try:
        behav = ollama_extract_behavior_block(trimmed) or {}
    except requests.exceptions.Timeout:
        logger.warning("[LLM-BEHAV] TIMEOUT")
        behav = {}

    try:
        art = ollama_extract_artifacts_block(trimmed) or {}
    except requests.exceptions.Timeout:
        logger.warning("[LLM-ARTIF] TIMEOUT")
        art = {}

    t.stop(
        extra=f"behav_keys={list(behav.keys())[:5]} art_keys={list(art.keys())[:5]}")
    logger.info(
        "[NONIOC] sizes | trimmed=%d behav=%s art=%s",
        len(trimmed),
        {k: type(v).__name__ for k, v in (behav or {}).items()},
        {k: type(v).__name__ for k, v in (art or {}).items()},
    )

    llm = {
        "file_type": art.get("file_type"),
        "detected_family": art.get("detected_family"),
        "risk_score": 1,
        "risk_level": "low",
        "behavior_summary": (behav.get("behavior_summary") or "").strip() or "LLM extraction (no summary).",
        "behaviors": behav.get("behaviors") or [],
        "iocs": iocs,
        "capabilities": art.get("capabilities") or [],
        "config": art.get("config"),
        "recommended_actions": art.get("recommended_actions") or [],
        "detection_hints": art.get("detection_hints") or [],
    }

    # Update sample fields if extracted
    if llm["file_type"]:
        sample.file_type = llm["file_type"]
    if llm["detected_family"]:
        sample.malware_family = llm["detected_family"]

    t = Timer("Create analysis row")
    analysis = MalwareAnalysis(
        id=uuid4(),
        sample_id=sample.id,
        risk_score=llm["risk_score"],
        risk_level=llm["risk_level"],
        behavior_summary=(llm["behavior_summary"] or "")[:2000],
        behaviors=llm["behaviors"] if isinstance(
            llm["behaviors"], list) else [],
    )

    db.add(analysis)
    db.flush()
    t.stop(extra=f"analysis_id={analysis.id}")

    t = Timer("Persist IOCs")
    for i in iocs:
        db.add(MalwareIOC(
            id=uuid4(),
            sample_id=sample.id,
            ioc_type=i["ioc_type"],
            value=i["value"],
            description=i.get("description"),
            source="report",
        ))
    t.stop(extra=f"ioc_rows={len(iocs)}")

    t = Timer("Persist capabilities")
    caps = llm["capabilities"] if isinstance(llm["capabilities"], list) else []
    for c in caps:
        c = str(c).strip()
        if c:
            db.add(MalwareCapability(
                id=uuid4(), sample_id=sample.id, capability=c))
    t.stop(extra=f"cap_rows={len(caps)}")

    t = Timer("Persist config")
    cfg = llm["config"]
    if isinstance(cfg, dict):
        db.add(MalwareConfig(
            id=uuid4(),
            sample_id=sample.id,
            ransom_note_name=cfg.get("ransom_note_name"),
            encryption_extension=cfg.get("encryption_extension"),
            target_folders=cfg.get("target_folders"),
        ))
        t.stop(extra="config_row=1")
    else:
        t.stop(extra="config_row=0")

    t = Timer("Persist recommended actions")
    acts = llm["recommended_actions"] if isinstance(
        llm["recommended_actions"], list) else []
    for a in acts:
        a = str(a).strip()
        if a:
            db.add(MalwareRecommendAction(
                id=uuid4(), sample_id=sample.id, action_text=a))
    t.stop(extra=f"action_rows={len(acts)}")

    t = Timer("Persist detection hints")
    hints = llm["detection_hints"] if isinstance(
        llm["detection_hints"], list) else []
    count = 0
    for h in hints:
        if not isinstance(h, dict):
            continue
        ht = str(h.get("hint_type") or "").strip()
        tx = str(h.get("hint_text") or "").strip()
        if ht and tx:
            db.add(MalwareDetectionHint(
                id=uuid4(),
                sample_id=sample.id,
                hint_type=ht,
                hint_text=tx,
            ))
            count += 1
    t.stop(extra=f"hint_rows={count}")

    t = Timer("DB commit")
    db.commit()
    t.stop()

    return AnalyzeFromReportResponse(
        sample_id=sample.id,
        analysis_id=analysis.id,
        risk_score=llm["risk_score"],
        risk_level=llm["risk_level"],
        behavior_summary=llm["behavior_summary"],
        iocs=iocs,
        capabilities=llm["capabilities"],
        config=llm["config"],
        recommended_actions=llm["recommended_actions"],
        detection_hints=llm["detection_hints"],
        extracted_text_len=len(report_text),
    )
