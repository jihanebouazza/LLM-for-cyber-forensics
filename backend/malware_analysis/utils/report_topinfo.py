from __future__ import annotations

import re
from datetime import datetime
from typing import Optional


_DATE_PATTERNS = [
    # "December 20, 2025 at 21:33:25"
    ("%B %d, %Y at %H:%M:%S", re.compile(
        r"\b([A-Za-z]+ \d{1,2}, \d{4} at \d{2}:\d{2}:\d{2})\b")),
    # "December 20, 2025 21:33:25"
    ("%B %d, %Y %H:%M:%S", re.compile(
        r"\b([A-Za-z]+ \d{1,2}, \d{4} \d{2}:\d{2}:\d{2})\b")),
]

_GENERIC_FAMILY_WORDS = {
    "loader", "rat", "remote access trojan", "trojan", "stealer", "worm", "backdoor",
    "malware", "malicious", "activity", "threat", "unknown",
}


def parse_anyrun_topinfo(report_text: str, max_scan_chars: int = 25000) -> dict:
    """
    Extract top-of-report 'General Info' like:
    File name, Full analysis URL, Verdict, Analysis date, OS, Tags, MIME, File info, MD5/SHA1/SHA256/SSDEEP.

    Returns keys:
      file_name, full_analysis, verdict, analysis_date, os, tags(list),
      mime, file_info, md5, sha1, sha256, ssdeep, threats(list)

    Notes:
    - threats parsing is best-effort from "Threats:" section if present in text.
    - We keep this deterministic (no LLM).
    """
    text = (report_text or "")[:max_scan_chars]

    def find_line_value(label: str) -> Optional[str]:
        # matches "Label: value" possibly with tabs/spaces
        m = re.search(rf"(?im)^\s*{re.escape(label)}\s*:\s*(.+?)\s*$", text)
        return m.group(1).strip() if m else None

    # Basic fields
    file_name = find_line_value("File name")
    full_analysis = find_line_value("Full analysis")
    verdict = find_line_value("Verdict")
    os_ = find_line_value("OS")
    mime = find_line_value("MIME")
    file_info = find_line_value("File info")
    md5 = find_line_value("MD5")
    sha1 = find_line_value("SHA1")
    sha256 = find_line_value("SHA256")
    ssdeep = find_line_value("SSDEEP")

    # Analysis date: sometimes the label is "Analysis date:" or it exists as a raw line.
    # analysis_date_str = find_line_value("Analysis date")
    # if not analysis_date_str:
    #     # Try to find a date pattern anywhere
    #     analysis_date_str = _find_any_date(text)

    # Tags: might be "Tags:" then next lines have tokens, OR same line has tokens.
    tags = _parse_tags(text)

    # Threats: "Threats:" then lines of types/family.
    threats = _parse_threats(text)

    return {
        "file_name": file_name,
        "full_analysis": full_analysis,
        "verdict": verdict,
        # "analysis_date": analysis_date_str,
        "os": os_,
        "tags": tags,
        "mime": mime,
        "file_info": file_info,
        "md5": md5,
        "sha1": sha1,
        "sha256": sha256,
        "ssdeep": ssdeep,
        "threats": threats,
    }


def map_sample_fields_from_topinfo(top: dict) -> dict:
    """
    Returns ONLY keys that exist in Malware_samples:
    filename, hash, file_type, role_in_attack, category, created_at, malware_family, variant_label
    (campaign_id intentionally not derived here)
    """
    out: dict = {}

    # filename
    fname = (top.get("file_name") or "").strip()
    if fname:
        out["filename"] = fname

    # # created_at from analysis_date (if parsable)
    # created_at = _parse_anyrun_datetime(top.get("analysis_date"))
    # if created_at:
    #     out["created_at"] = created_at

    # hash: prefer sha256 then sha1 then md5
    best_hash = _pick_hash(top)
    if best_hash:
        out["hash"] = best_hash  # store like "sha256:..." etc

    # file_type: prefer "File info", fallback to "MIME"
    file_info = (top.get("file_info") or "").strip()
    mime = (top.get("mime") or "").strip()
    if file_info:
        out["file_type"] = file_info
    elif mime:
        out["file_type"] = mime

    # category from verdict (keep it simple and consistent)
    verdict = (top.get("verdict") or "").lower()
    if "malicious" in verdict:
        out["category"] = "malware"
    elif verdict:
        out["category"] = "unknown"

    # role_in_attack from threats/tags keywords
    tags = [t.lower() for t in (top.get("tags") or [])]
    threats = [t.lower() for t in (top.get("threats") or [])]
    role = _guess_role(tags, threats)
    if role:
        out["role_in_attack"] = role

    # malware_family + variant_label
    family, variant = _pick_family_and_variant(tags, threats)
    if family:
        out["malware_family"] = family
    if variant:
        out["variant_label"] = variant

    return out


# ---------------- helpers ----------------

# def _find_any_date(text: str) -> Optional[str]:
#     for _, rx in _DATE_PATTERNS:
#         m = rx.search(text or "")
#         if m:
#             return m.group(1).strip()
#     return None


# def _parse_anyrun_datetime(s: Optional[str]) -> Optional[datetime]:
#     if not s:
#         return None
#     ss = s.strip()
#     for fmt, rx in _DATE_PATTERNS:
#         m = rx.search(ss)
#         if not m:
#             continue
#         ds = m.group(1).strip()
#         try:
#             return datetime.strptime(ds, fmt)
#         except Exception:
#             pass
#     # last resort: try direct parsing without regex group
#     for fmt, _ in _DATE_PATTERNS:
#         try:
#             return datetime.strptime(ss, fmt)
#         except Exception:
#             pass
#     return None


def _pick_hash(top: dict) -> Optional[str]:
    sha256 = (top.get("sha256") or "").strip()
    if sha256:
        return f"sha256:{sha256.lower()}"

    sha1 = (top.get("sha1") or "").strip()
    if sha1:
        return f"sha1:{sha1.lower()}"

    md5 = (top.get("md5") or "").strip()
    if md5:
        return f"md5:{md5.lower()}"

    return None


def _parse_tags(text: str) -> list[str]:
    # Try "Tags:" line first
    m = re.search(r"(?im)^\s*Tags\s*:\s*(.*?)\s*$", text)
    if m:
        line = (m.group(1) or "").strip()
        if line:
            return _split_tokens(line)

    # Else: after "Tags:" label (next lines until blank / another label)
    m2 = re.search(r"(?im)^\s*Tags\s*:\s*$", text)
    if not m2:
        return []

    start = m2.end()
    tail = text[start:]
    lines = []
    for ln in tail.splitlines():
        ln = ln.strip()
        if not ln:
            break
        # stop if looks like another "Label:"
        if re.match(r"(?i)^[A-Za-z][A-Za-z\s]+:\s*", ln):
            break
        lines.append(ln)

    tokens: list[str] = []
    for ln in lines:
        tokens.extend(_split_tokens(ln))
    # dedup preserve order
    seen = set()
    out = []
    for t in tokens:
        if t and t not in seen:
            seen.add(t)
            out.append(t)
    return out


def _parse_threats(text: str) -> list[str]:
    # "Threats:" can be:
    # Threats: Loader / Remote Access Trojan / XWorm ...
    m = re.search(r"(?im)^\s*Threats\s*:\s*(.*?)\s*$", text)
    if m:
        line = (m.group(1) or "").strip()
        if line:
            return _split_threats_line(line)

    # Or "Threats:" then multiple lines
    m2 = re.search(r"(?im)^\s*Threats\s*:\s*$", text)
    if not m2:
        return []
    start = m2.end()
    tail = text[start:]

    lines = []
    for ln in tail.splitlines():
        ln = ln.strip()
        if not ln:
            break
        if re.match(r"(?i)^[A-Za-z][A-Za-z\s]+:\s*", ln):  # next section
            break
        lines.append(ln)

    threats: list[str] = []
    for ln in lines:
        threats.extend(_split_threats_line(ln))
    # dedup preserve order
    seen = set()
    out = []
    for t in threats:
        if t and t.lower() not in seen:
            seen.add(t.lower())
            out.append(t)
    return out


def _split_tokens(s: str) -> list[str]:
    # tags are often space separated. keep simple.
    return [t.strip() for t in re.split(r"[,\s]+", s) if t.strip()]


def _split_threats_line(s: str) -> list[str]:
    # threats may be separated by commas or newlines; keep phrases
    parts = [p.strip() for p in re.split(r"[,\|/]+", s) if p.strip()]
    # also allow "Remote Access Trojan" style phrases
    return parts


def _guess_role(tags: list[str], threats: list[str]) -> Optional[str]:
    pool = " ".join(tags + threats).lower()

    if "loader" in pool:
        return "loader"
    if "remote access trojan" in pool or re.search(r"\brat\b", pool):
        return "rat"
    if "stealer" in pool:
        return "stealer"
    if "dropper" in pool:
        return "dropper"
    if "ransom" in pool:
        return "ransomware"

    return None


def _pick_family_and_variant(tags: list[str], threats: list[str]) -> tuple[Optional[str], Optional[str]]:
    """
    Family: prefer a specific name like xworm from tags/threats
    Variant_label: can mirror family, or be second best specific token.
    """
    # candidates from tags first, then threats
    cand = []
    for t in tags:
        tt = t.strip().lower()
        if tt and tt not in _GENERIC_FAMILY_WORDS and len(tt) >= 3:
            cand.append(tt)
    for th in threats:
        tt = th.strip().lower()
        if tt and tt not in _GENERIC_FAMILY_WORDS and len(tt) >= 3:
            # keep phrase family like "xworm"
            cand.append(tt)

    # dedup preserve order
    seen = set()
    cand2 = []
    for x in cand:
        if x not in seen:
            seen.add(x)
            cand2.append(x)

    if not cand2:
        return None, None

    family = cand2[0]
    variant = cand2[0]  # simplest
    return family, variant
